<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://camel.apache.org/schema/spring
    http://camel.apache.org/schema/spring/camel-spring.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context-3.0.xsd">
    <context:property-placeholder location="classpath:/librarycloud.env.properties"/>

    <!-- bootstrap the java config -->
    <bean class="edu.harvard.libcomm.pipeline.AWSConfig"/>

    <bean id="activemq" class="org.apache.activemq.camel.component.ActiveMQComponent">
        <property name="connectionFactory">
            <bean class="org.apache.activemq.ActiveMQConnectionFactory">
                <property name="brokerURL" value="${activemq.broker.url}"/>
                <property name="userName" value="${activemq.username}"/>
                <property name="password" value="${activemq.password}"/>
                <property name="clientID" value="${activemq.clientid}"/>
                <property name="redeliveryPolicy">
                    <!--<property name="deliveryPersistent" value="true" />-->
                    <bean class="org.apache.activemq.RedeliveryPolicy">
                        <property name="maximumRedeliveries" value="5"/>
                        <property name="redeliveryDelay" value="5000"/>
                    </bean>
                </property>
            </bean>
        </property>
    </bean>

    <!-- Custom S3 marshaller to place body on S3 -->
    <bean id="cloudbody" class="edu.harvard.libcomm.pipeline.MessageBodyS3Marshaller">
        <!-- force use of s3 bucket until we determine why prod direct to sqs fouls encoding -->
        <constructor-arg value="100"/>
        <!--<constructor-arg value="20000" />-->
        <!-- If message size in bytes is greater than this, save body to S3 -->
        <constructor-arg value="${librarycloud.s3.cache_bucket}.${librarycloud.sqs.environment}"/>
    </bean>

    <!-- Set a shorter timeout for shutdown, primarily for testing purposes. Default is 300. -->
    <bean id="shutdown" class="org.apache.camel.impl.DefaultShutdownStrategy">
        <property name="timeout" value="30"/>
    </bean>
    <!-- Configure display of trace log messages -->
    <bean id="traceFormatter" class="org.apache.camel.processor.interceptor.DefaultTraceFormatter">
        <property name="showBody" value="false"/>
        <property name="showHeaders" value="false"/>
    </bean>

    <!-- Definition of beans that handle processing of items in the pipeline -->
    <bean id="marcSplitter" class="edu.harvard.libcomm.pipeline.Splitter">
        <property name="splitter">
            <bean class="edu.harvard.libcomm.pipeline.marc.MarcSplitter">
                <constructor-arg value="500000"/>
                <!-- Approx. max size of messages, in bytes -->
            </bean>
        </property>
    </bean>

    <bean id="tedSplitter" class="edu.harvard.libcomm.pipeline.Splitter">
        <property name="splitter">
            <bean class="edu.harvard.libcomm.pipeline.ted.TedSplitter">
                <constructor-arg value="100"/>
                <!-- Approx. max size of messages, in bytes -->
            </bean>
        </property>
    </bean>

    <bean id="deleteSplitter" class="edu.harvard.libcomm.pipeline.Splitter">
        <property name="splitter">
            <bean class="edu.harvard.libcomm.pipeline.delete.DeleteFileSplitter"/>
        </property>
    </bean>

    <bean id="updateSplitter" class="edu.harvard.libcomm.pipeline.Splitter">
        <property name="splitter">
            <bean class="edu.harvard.libcomm.pipeline.update.UpdateFileSplitter"/>
        </property>
    </bean>

    <bean id="eadSplitter" class="edu.harvard.libcomm.pipeline.Splitter">
        <property name="splitter">
            <bean class="edu.harvard.libcomm.pipeline.ead.EADSplitter"/>
        </property>
    </bean>
    <bean id="eadRawSplitter" class="edu.harvard.libcomm.pipeline.RawSplitter">
        <property name="splitter">
            <bean class="edu.harvard.libcomm.pipeline.ead.EADRawSplitter"/>
        </property>
    </bean>
    <bean id="viaSplitter" class="edu.harvard.libcomm.pipeline.Splitter">
        <property name="splitter">
            <bean class="edu.harvard.libcomm.pipeline.via.VIASplitter"/>
        </property>
    </bean>
    <bean id="viaRawSplitter" class="edu.harvard.libcomm.pipeline.RawSplitter">
        <property name="splitter">
            <bean class="edu.harvard.libcomm.pipeline.via.VIARawSplitter"/>
        </property>
    </bean>

    <bean id="modsSplitter" class="edu.harvard.libcomm.pipeline.Splitter">
        <property name="splitter">
            <bean class="edu.harvard.libcomm.pipeline.mods.MODSSplitter"/>
        </property>
    </bean>

    <bean id="modsItemCollectionSplitter" class="edu.harvard.libcomm.pipeline.MessageSplitter">
        <property name="splitter">
            <bean class="edu.harvard.libcomm.pipeline.mods.MODSSplitter"/>
        </property>
    </bean>

    <bean id="modsAggregator" class="edu.harvard.libcomm.pipeline.MODSAggregatorStrategy"/>

    <bean id="modsEADRawAggregator" class="edu.harvard.libcomm.pipeline.MODSRawAggregatorStrategy">
        <property name="source" value="OASIS"/>
    </bean>

    <bean id="modsVIARawAggregator" class="edu.harvard.libcomm.pipeline.MODSRawAggregatorStrategy">
        <property name="source" value="VIA"/>
    </bean>

    <bean id="modsRawAggregator" class="edu.harvard.libcomm.pipeline.MODSRawAggregatorStrategy">
        <property name="source" value="ALMA"/>
    </bean>

    <bean id="marcxmlAlmaRawAggregator"
        class="edu.harvard.libcomm.pipeline.MARCXMLRawAggregatorStrategy">
        <property name="source" value="ALMA"/>
    </bean>

    <bean id="newlineAggregator" class="edu.harvard.libcomm.pipeline.NewlineAggregatorStrategy"/>

    <bean id="extractPayloadProcessor" class="edu.harvard.libcomm.pipeline.ExtractPayloadProcessor"/>

    <bean id="modsProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.marc.ModsProcessor">
                <property name="stylesheet" value="src/main/resources/MARC21slim2MODS3-6.xsl"/>
            </bean>
        </property>
    </bean>
    <bean id="modsProcessorAlma" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.marc.ModsProcessor">
                <property name="stylesheet" value="src/main/resources/MARC21slim2MODS3-6.xsl"/>
            </bean>
        </property>
    </bean>
    <bean id="filterUnchangedProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.FilterUnchangedProcessor"/>
        </property>
    </bean>
    <bean id="filterSuppressedProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.FilterSuppressedProcessor"/>
        </property>
    </bean>
    <bean id="filterUnchangedMarcProcessor"
        class="edu.harvard.libcomm.pipeline.FilterUnchangedMarcProcessor"/>
    <bean id="holdingsProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.enrich.HoldingsProcessor"/>
        </property>
    </bean>

    <bean id="drsExtensionsProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.enrich.DRSExtensionsProcessor"/>
        </property>
    </bean>

    <bean id="drsExtensionsUpdateProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.enrich.DRSExtensionsUpdateProcessor"/>
        </property>
    </bean>

    <bean id="drsExtensionsNewUpdateProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.enrich.DRSExtensionsNewUpdateProcessor"/>
        </property>
    </bean>

    <bean id="solrDrsExtensionsProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.solr.SolrDrsExtensionsProcessor">
                <property name="commitWithinTime" value="30000"/>
            </bean>
        </property>
    </bean>

    <bean id="thumbsProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.enrich.PDSThumbsProcessor"/>
        </property>
    </bean>

    <bean id="addMarcLocationProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.enrich.AddMarcLocationProcessor">
                <!--<property name="marcBaseUrl" value="https://s3.amazonaws.com/${librarycloud.s3.marc_bucket}.${librarycloud.sqs.environment}/" />-->
                <property name="marcBaseUrl"
                    value="https://s3.amazonaws.com/${librarycloud.s3.marc_bucket}/"/>
            </bean>
        </property>
    </bean>
    <bean id="stackscoreProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.enrich.StackScoreProcessor"/>
        </property>
    </bean>
    <bean id="lccProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.enrich.LCCProcessor"/>
        </property>
    </bean>
    <bean id="collectionsProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.enrich.CollectionsProcessor"/>
        </property>
    </bean>
    <bean id="collectionUpdateProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.enrich.CollectionUpdateProcessor"/>
        </property>
    </bean>
    <bean id="publishProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.enrich.PublishProcessor"/>
        </property>
    </bean>
    <bean id="solrLoadProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.solr.SolrProcessor">
                <property name="commitWithinTime" value="30000"/>
            </bean>
        </property>
    </bean>
    <bean id="solrLoadProcessorImmediate" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.solr.SolrProcessor"/>
        </property>
    </bean>

    <bean id="solrHoldingsProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.solr.SolrHoldingsProcessor">
                <property name="commitWithinTime" value="30000"/>
            </bean>
        </property>
    </bean>

    <bean id="solrAlmaHoldingsProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.solr.SolrAlmaHoldingsProcessor">
                <property name="commitWithinTime" value="30000"/>
            </bean>
        </property>
    </bean>

    <bean id="almaHoldingsProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.enrich.AlmaHoldingsProcessor"/>
        </property>
    </bean>

    <bean id="deleteProcessor" class="edu.harvard.libcomm.pipeline.delete.DeleteFile"> </bean>

    <bean id="solrDeleteProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.solr.SolrDeleteProcessor"/>
        </property>
    </bean>

    <bean id="solrHoldingsDeleteProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.solr.SolrHoldingsDeleteProcessor"/>
        </property>
    </bean>

    <bean id="s3DeleteProcessor" class="edu.harvard.libcomm.pipeline.LibCommProcessor">
        <property name="processor">
            <bean class="edu.harvard.libcomm.pipeline.delete.S3DeleteProcessor">
                <!--<property name="bucket" value="${librarycloud.s3.marc_bucket}.${librarycloud.sqs.environment}" />-->
                <property name="bucket" value="${librarycloud.s3.marc_bucket}"/>
            </bean>
        </property>
    </bean>

    <bean id="refreshFromS3Processor"
        class="edu.harvard.libcomm.pipeline.enrich.RefreshFromS3Processor"/>

    <bean id="s3ListProcessor" class="edu.harvard.libcomm.pipeline.enrich.S3ListProcessor"/>

    <bean id="prepareURI" class="edu.harvard.libcomm.pipeline.PrepareURIForHTTPEndpoint"/>

    <bean id="drsMdsProcessor" class="edu.harvard.libcomm.pipeline.enrich.DrsMdsProcessor"/>
    <bean id="drsMdsSolrProcessor" class="edu.harvard.libcomm.pipeline.solr.DrsMdsSolrProcessor"/>
    <bean id="drsMdsUpdateProcessor"
        class="edu.harvard.libcomm.pipeline.enrich.DrsMdsUpdateProcessor"/>


    <!-- Connecting to mongo from within ted classes, but save for reference
    <bean id="mongoBean" class="com.mongodb.MongoClient">
        <constructor-arg>
            <ref bean="mongoClientURI" />
        </constructor-arg>
    </bean>

    <bean id="mongoClientURI" class="com.mongodb.MongoClientURI">
        <constructor-arg name="uri" value="mongodb://${mongo.username}:${mongo.password}@${mongo.host}:27072/${mongo.db}" />
    </bean>
-->
    <camelContext id="sqsContext" xmlns="http://camel.apache.org/schema/spring"
        xmlns:marcxml="http://www.loc.gov/MARC21/slim" trace="false">
        <!-- Environment-specific properties -->
        <propertyPlaceholder id="librarycloud-properties"
            location="classpath:/librarycloud.env.properties"/>
        <!-- Error handling behavior -->
        <errorHandler id="eh" redeliveryPolicyRef="myPolicy" type="DeadLetterChannel"
            deadLetterUri="direct:dead-letter"/>

        <!--<errorHandler id="ehmq" type="DefaultErrorHandler">
            <redeliveryPolicy maximumRedeliveries="5"
            retryAttemptedLogLevel="WARN"
            backOffMultiplier="2"
            useExponentialBackOff="true"/>
        </errorHandler>-->

        <redeliveryPolicyProfile id="myPolicy" maximumRedeliveries="0"/>
        <route id="dead-letter">
            <from uri="direct:dead-letter"/>
            <!--<to uri="log:edu.harvard.libcomm.deadletterqueue?level=ERROR"/>-->
            <!-- Post to the AWS dead letter queue, and handle errors (e.g. file size exceeded) -->
            <doTry>
                <setHeader headerName="filepath">
                    <xpath>/lib_comm_message/payload/filepath/text()</xpath>
                </setHeader>
                <setHeader headerName="source">
                    <xpath>/lib_comm_message/payload/source/text()</xpath>
                </setHeader>
                <setHeader headerName="command">
                    <xpath>/lib_comm_message/command/text()</xpath>
                </setHeader>
                <transform>
                    <simple>${header.filepath},${header.source},${header.command},${exception}}</simple>
                </transform>
                <to
                    uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-dead-letter?amazonSQSClient=#sqsClient"/>
                <to uri="log:edu.harvard.libcomm.deadletterqueue?level=ERROR"/>
                <doCatch>
                    <!-- If can't post the full message to the dead letter queue, post only the headers to the queue -->
                    <exception>java.lang.Exception</exception>
                    <to uri="log:edu.harvard.libcomm.deadletterqueue?level=ERROR&amp;showAll=true"/>
                    <transform>
                        <simple>Error placing failed message on dead letter queue. Headers for affected message: ${headers}. Exception: ${exception}${exception.stacktrace}</simple>
                    </transform>
                    <doTry>
                        <to
                            uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-dead-letter?amazonSQSClient=#sqsClient"/>
                        <doCatch>
                            <!-- If can't even post the headers to the dead letter queue, log error and be done -->
                            <exception>java.lang.Exception</exception>
                            <transform>
                                <simple>Error placing failed message headers on dead letter queue. Headers for affected message: ${headers} Exception: ${exception}${exception.stacktrace}</simple>
                            </transform>
                            <to
                                uri="log:edu.harvard.libcomm.deadletterqueue?level=ERROR&amp;showAll=true"
                            />
                        </doCatch>
                    </doTry>
                </doCatch>
            </doTry>
        </route>

        <!-- Setup bucket used by cloudbody marshalling service if it does not already exist -->
        <route id="forceCreationOfS3Bucket" errorHandlerRef="eh">
            <from uri="direct:nothing"/>
            <to
                uri="aws-s3://{{librarycloud.s3.cache_bucket}}.{{librarycloud.sqs.environment}}?amazonS3Client=#s3Client"
            />
        </route>

        <!-- ============================== -->
        <!-- Alma Bib records ingest and normalization -->
        <!-- ============================== -->

        <route id="alma-ingest" errorHandlerRef="eh">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-ingest-alma?amazonSQSClient=#sqsClient&amp;visibilityTimeout=1800&amp;extendMessageVisibility=true"/>
            <split>
                <xtokenize mode="t">//filepath</xtokenize>
                <bean ref="prepareURI" method="prepare"/>
                <!-- Download the file identified in the message header. This URI (http://www.example.com) is ignored -->
                <to uri="http://www.example.com"/>
                <to uri="direct:alma-ingest-file"/>
            </split>
        </route>
        <route id="alma-ingest-file" errorHandlerRef="eh">
            <from uri="direct:alma-ingest-file"/>
            <doTry>
                <split streaming="true">
                    <xtokenize>//record</xtokenize>
                    <setHeader headerName="outerSplitIndex">
                        <simple>${header.CamelSplitIndex}</simple>
                    </setHeader>
                    <aggregate strategyRef="marcxmlAlmaRawAggregator" completionSize="100"
                        completionInterval="10000">
                        <correlationExpression>
                            <simple>all</simple>
                        </correlationExpression>
                        <completionPredicate>
                            <simple>${header.messageLength} > 150000</simple>
                        </completionPredicate>
                        <process ref="filterSuppressedProcessor"/>
                        <!--<marshal><custom ref="cloudbody"/></marshal>-->
                        <multicast parallelProcessing="true">
                            <to
                                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-normalize-marcxml?amazonSQSClient=#sqsClient"/>
                            <to
                                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-upload-marc?amazonSQSClient=#sqsClient"
                            />
                        </multicast>
                        <!-- <to uri="file://{{librarycloud.files.basepath}}/normalize-marcxml?fileName=alma-${header.CamelSplitIndex}" /> -->
                    </aggregate>
                </split>
                <doCatch>
                    <exception>java.lang.Exception</exception>
                    <to uri="direct:dead-letter"/>
                </doCatch>
            </doTry>
        </route>
        <!-- ingest only to s3, used for ensuring s3 bucket has latest modified -->
        <route id="alma-ingest-s3" errorHandlerRef="eh">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-ingest-alma-s3?amazonSQSClient=#sqsClient&amp;visibilityTimeout=1800&amp;extendMessageVisibility=true"/>
            <split>
                <xtokenize mode="t">//filepath</xtokenize>
                <bean ref="prepareURI" method="prepare"/>
                <!-- Download the file identified in the message header. This URI (http://www.example.com) is ignored -->
                <to uri="http://www.example.com"/>
                <to uri="direct:alma-ingest-s3-file"/>
            </split>
        </route>
        <route id="alma-ingest-s3-file" errorHandlerRef="eh">
            <from uri="direct:alma-ingest-s3-file"/>
            <doTry>
                <split streaming="true">
                    <xtokenize>//record</xtokenize>
                    <setHeader headerName="outerSplitIndex">
                        <simple>${header.CamelSplitIndex}</simple>
                    </setHeader>
                    <aggregate strategyRef="marcxmlAlmaRawAggregator" completionSize="100"
                        completionInterval="10000">
                        <correlationExpression>
                            <simple>all</simple>
                        </correlationExpression>
                        <completionPredicate>
                            <simple>${header.messageLength} > 150000</simple>
                        </completionPredicate>
                        <process ref="filterSuppressedProcessor"/>
                        <to
                            uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-upload-marc?amazonSQSClient=#sqsClient"
                        />
                    </aggregate>
                </split>
                <doCatch>
                    <exception>java.lang.Exception</exception>
                    <to uri="direct:dead-letter"/>
                </doCatch>
            </doTry>
        </route>

        <!-- ============================== -->
        <!-- Alma Holdings records ingest   -->
        <!-- ============================== -->
        <route id="alma-holdings-ingest" errorHandlerRef="eh">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-ingest-alma-holdings?amazonSQSClient=#sqsClient&amp;visibilityTimeout=1800&amp;extendMessageVisibility=true"/>
            <split>
                <xtokenize mode="t">//filepath</xtokenize>
                <bean ref="prepareURI" method="prepare"/>
                <!-- Download the file identified in the message header. This URI (http://www.example.com) is ignored -->
                <to uri="http://www.example.com"/>
                <to uri="direct:alma-holdings-ingest-file"/>
            </split>
        </route>
        <route id="alma-holdings-ingest-file" errorHandlerRef="eh">
            <from uri="direct:alma-holdings-ingest-file"/>
            <doTry>
                <split streaming="true">
                    <xtokenize>//record</xtokenize>
                    <setHeader headerName="outerSplitIndex">
                        <simple>${header.CamelSplitIndex}</simple>
                    </setHeader>
                    <aggregate strategyRef="marcxmlAlmaRawAggregator" completionSize="100"
                        completionInterval="10000">
                        <correlationExpression>
                            <simple>all</simple>
                        </correlationExpression>
                        <completionPredicate>
                            <simple>${header.messageLength} > 150000</simple>
                        </completionPredicate>
                        <!-- multicast doesn't work, do holdings first, then separate ingest for updating from s3 -->
                        <to
                            uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-update-holdings?amazonSQSClient=#sqsClient"/>
                        <!-- <to uri="file://{{librarycloud.files.basepath}}/normalize-marcxml?fileName=alma-${header.CamelSplitIndex}" /> -->
                        <!--<multicast>
                            <to uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-update-holdings?amazonSQSClient=#sqsClient" />
                            <to uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-bibidlist-from-holdings?amazonSQSClient=#sqsClient" />
                        </multicast>-->
                    </aggregate>
                </split>
                <doCatch>
                    <exception>java.lang.Exception</exception>
                    <to uri="direct:dead-letter"/>
                </doCatch>
            </doTry>
        </route>

        <route id="alma-holdings-update" errorHandlerRef="eh">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-update-holdings?amazonSQSClient=#sqsClient&amp;visibilityTimeout=1800&amp;extendMessageVisibility=true"/>
            <process ref="solrAlmaHoldingsProcessor"/>
            <to
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-done?amazonSQSClient=#sqsClient"
            />
        </route>

        <!-- Transform MARCXML to MODS -->
        <route id="marctomods-seda" errorHandlerRef="eh">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-normalize-marcxml?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"/>
            <unmarshal>
                <custom ref="cloudbody"/>
            </unmarshal>
            <to uri="seda:normalize-marcxml?size=20&amp;blockWhenFull=true"/>
        </route>
        <route id="marctomods" errorHandlerRef="eh">
            <from uri="seda:normalize-marcxml?concurrentConsumers=4"/>
            <!-- Slightly different MODS transformers depending on whether it's coming from Aleph or Alma -->
            <choice>
                <when>
                    <xpath>string-length(/lib_comm_message/payload/data) = 0</xpath>
                    <to
                        uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-empty-message?amazonSQSClient=#sqsClient"
                    />
                </when>
                <otherwise>
                    <process ref="modsProcessor"/>
                    <process ref="addMarcLocationProcessor"/>
                    <marshal>
                        <custom ref="cloudbody"/>
                    </marshal>
                    <!-- <to uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-start?amazonSQSClient=#sqsClient" /> -->
                    <to
                        uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-alma-holdings?amazonSQSClient=#sqsClient"
                    />
                </otherwise>
            </choice>

        </route>

        <!-- Extract the record ID from the MARCXML, and upload the record to S3, keyed by record ID-->
        <route id="uploadmarc-seda" errorHandlerRef="eh">
            <!-- Note the reduced messages per poll, so we don't end up getting messages timed out, since this takes a while -->
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-upload-marc?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=1&amp;visibilityTimeout=1800&amp;extendMessageVisibility=true"/>
            <!--<unmarshal><custom ref="cloudbody"/></unmarshal>-->
            <to uri="seda:upload-marc?size=20&amp;blockWhenFull=true"/>
        </route>
        <route id="upload-marc" errorHandlerRef="eh">
            <from uri="seda:upload-marc?concurrentConsumers=4"/>
            <process ref="extractPayloadProcessor"/>
            <split>
                <tokenize token="record" inheritNamespaceTagName="collection" xml="true"/>
                <setHeader headerName="recordFileName">
                    <xpath resultType="java.lang.String">
                        /marcxml:record/marcxml:controlfield[@tag='001']
                    </xpath>
                </setHeader>
                <!--<process ref="filterUnchangedMarcProcessor"/>-->
                <choice>
                    <when>
                        <simple>${in.body} != ""</simple>
                        <setHeader headerName="CamelAwsS3Key">
                            <simple>${header.recordFileName}</simple>
                        </setHeader>
                        <setHeader headerName="CamelAwsS3CannedAcl">
                            <simple>PublicRead</simple>
                        </setHeader>
                        <!--<to uri="aws-s3://{{librarycloud.s3.marc_bucket}}.{{librarycloud.sqs.environment}}?amazonS3Client=#s3Client" />-->
                        <to uri="aws-s3://{{librarycloud.s3.marc_bucket}}?amazonS3Client=#s3Client"
                        />
                    </when>
                </choice>
            </split>
        </route>

        <!-- ============================== -->
        <!-- OASIS ingest and normalization -->
        <!-- ============================== -->
        <route id="oasis-ingest-seda" errorHandlerRef="eh">
            <!-- <from uri="file://{{librarycloud.files.basepath}}/ingest-oasis" /> -->
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-ingest-oasis?amazonSQSClient=#sqsClient&amp;visibilityTimeout=1800&amp;extendMessageVisibility=true"/>
            <to uri="seda:oasis-ingest-seda?size=4&amp;blockWhenFull=true"/>
        </route>

        <route id="oasis-ingest" errorHandlerRef="eh">
            <from uri="seda:oasis-ingest-seda?concurrentConsumers=4"/>
            <!-- Try block required for errors thrown out of the splitter -->
            <doTry>
                <split streaming="true" parallelProcessing="true">
                    <method bean="eadSplitter" method="split"/>
                    <aggregate strategyRef="modsAggregator" completionSize="100"
                        completionInterval="10000">
                        <correlationExpression>
                            <simple>all</simple>
                        </correlationExpression>
                        <completionPredicate>
                            <simple>${header.messageLength} > 150000</simple>
                        </completionPredicate>
                        <marshal>
                            <custom ref="cloudbody"/>
                        </marshal>
                        <to
                            uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-drs-extensions?amazonSQSClient=#sqsClient"/>
                        <!-- <to uri="file://{{librarycloud.files.basepath}}/enrich-drs-extensions?fileName=${header.CamelSplitIndex}" /> -->
                    </aggregate>
                </split>
                <doCatch>
                    <exception>java.lang.Exception</exception>
                    <to uri="direct:dead-letter"/>
                </doCatch>
            </doTry>
        </route>

        <!-- VIA ingest and normalization -->
        <route id="via-ingest" errorHandlerRef="eh">
            <!--
                         -->
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-ingest-via?amazonSQSClient=#sqsClient&amp;visibilityTimeout=1800&amp;extendMessageVisibility=true"/>
            <split>
                <xtokenize mode="t">//filepath</xtokenize>
                <bean ref="prepareURI" method="prepare"/>
                <!-- Download the file identified in the message header. This URI (http://www.example.com) is ignored -->
                <to uri="http://www.example.com"/>
                <!-- <to uri="file://{{librarycloud.files.basepath}}/ingest-via-file-url?fileName=via-file-${id}" /> -->
                <to uri="direct:via-ingest-file"/>
            </split>
        </route>
        <route id="via-ingest-file" errorHandlerRef="eh">
            <from uri="direct:via-ingest-file"/>
            <doTry>
                <split streaming="true">
                    <tokenize token="viaRecord" xml="true"/>
                    <setHeader headerName="outerSplitIndex">
                        <simple>${header.CamelSplitIndex}</simple>
                    </setHeader>

                    <split streaming="true" parallelProcessing="true">
                        <method bean="viaRawSplitter" method="split"/>
                        <aggregate strategyRef="modsAggregator" completionSize="100"
                            completionInterval="10000">
                            <correlationExpression>
                                <simple>all</simple>
                            </correlationExpression>
                            <completionPredicate>
                                <simple>${header.messageLength} > 150000</simple>
                            </completionPredicate>
                            <marshal>
                                <custom ref="cloudbody"/>
                            </marshal>
                            <to
                                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-drs-extensions?amazonSQSClient=#sqsClient"/>
                            <!-- <to uri="file://{{librarycloud.files.basepath}}/enrich-drs-extensions?fileName=${header.outerSplitIndex}-${header.CamelSplitIndex}" /> -->
                        </aggregate>
                    </split>
                </split>
                <doCatch>
                    <exception>java.lang.Exception</exception>
                    <to uri="direct:dead-letter"/>
                </doCatch>
            </doTry>
        </route>

        <!-- Route messages to the correct part of the enrich pipeline -->
        <route id="enrich-start" errorHandlerRef="eh">
            <!-- <from uri="file://{{librarycloud.files.basepath}}//enrich-start" /> -->
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-start?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"/>
            <unmarshal>
                <custom ref="cloudbody"/>
            </unmarshal>
            <choice>
                <when>
                    <xpath>//source = 'alma'</xpath>
                    <to uri="seda:enrich-alma-holdings?size=20&amp;blockWhenFull=true"/>
                </when>
                <when>
                    <xpath>//source = 'ALMA'</xpath>
                    <to uri="seda:enrich-alma-holdings?size=20&amp;blockWhenFull=true"/>
                </when>
                <otherwise>
                    <!-- Skip MODS aggregation steps for non-aleph/alma records -->
                    <to uri="seda:enrich-drs-extensions?size=20&amp;blockWhenFull=true"/>
                </otherwise>
            </choice>
        </route>

        <!-- Add holdings to Alma -->
        <route id="addalmaholdingstomods-seda" errorHandlerRef="eh">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-alma-holdings?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"/>
            <unmarshal>
                <custom ref="cloudbody"/>
            </unmarshal>
            <to uri="seda:enrich-alma-holdings?size=20&amp;blockWhenFull=true"/>
        </route>
        <route id="addalmaholdingstomods" errorHandlerRef="eh">
            <from uri="seda:enrich-alma-holdings?concurrentConsumers=5"/>
            <process ref="almaHoldingsProcessor"/>
            <marshal>
                <custom ref="cloudbody"/>
            </marshal>
            <to
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-split-collections?amazonSQSClient=#sqsClient"
            />
        </route>

        <route id="almamodssplit-seda" errorHandlerRef="eh">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-split-collections?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"/>
            <unmarshal>
                <custom ref="cloudbody"/>
            </unmarshal>
            <to uri="seda:enrich-split-collections?size=20&amp;blockWhenFull=true"/>
        </route>

        <route id="almamodssplit" errorHandlerRef="eh">
            <!--<from uri="file://{{librarycloud.files.basepath}}//enrich-04" />-->
            <from uri="seda:enrich-split-collections?concurrentConsumers=5"/>
            <!--<from uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-04?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"/>-->
            <doTry>
                <split streaming="true" parallelProcessing="true">
                    <method bean="modsItemCollectionSplitter" method="split"/>
                    <!--<marshal><custom ref="cloudbody"/></marshal>-->
                    <aggregate strategyRef="modsRawAggregator" completionSize="100"
                        completionInterval="10000">
                        <correlationExpression>
                            <simple>all</simple>
                        </correlationExpression>
                        <completionPredicate>
                            <simple>${header.messageLength} > 150000</simple>
                        </completionPredicate>
                        <marshal>
                            <custom ref="cloudbody"/>
                        </marshal>
                        <!--<to uri="seda:enrich-drs-extensions?size=20&amp;blockWhenFull=true" />-->
                        <!--<to uri="file://{{librarycloud.files.basepath}}/enrich-drs-extensions" />-->
                        <to
                            uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-drs-extensions?amazonSQSClient=#sqsClient"
                        />
                    </aggregate>
                </split>
                <doCatch>
                    <exception>java.lang.Exception</exception>
                    <!--<to uri="file://{{librarycloud.files.basepath}}/dead-letter" />-->
                    <to uri="direct:dead-letter"/>
                </doCatch>
            </doTry>
        </route>

        <route id="adddrsextensionsstomods-seda" errorHandlerRef="eh">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-drs-extensions?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"/>
            <unmarshal>
                <custom ref="cloudbody"/>
            </unmarshal>
            <to uri="seda:enrich-drs-extensions?size=20&amp;blockWhenFull=true"/>
        </route>
        <route id="adddrsextensionstomods" errorHandlerRef="eh">
            <!--<from uri="file://{{librarycloud.files.basepath}}//enrich-drs-extensions" />-->
            <from uri="seda:enrich-drs-extensions?concurrentConsumers=1"/>
            <doTry>
                <process ref="drsExtensionsProcessor"/>
                <marshal>
                    <custom ref="cloudbody"/>
                </marshal>
                <!-- we want to do this, but it seems to cause glitches when doing full marc ingests.
                Try full ingest sending via as well, tho not necessary, to see if that helps-->
                <choice>
                    <when>
                        <xpath>//source = 'via'</xpath>
                        <to
                            uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-collections?amazonSQSClient=#sqsClient"
                        />
                    </when>
                    <when>
                        <xpath>//source = 'VIA'</xpath>
                        <to
                            uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-collections?amazonSQSClient=#sqsClient"
                        />
                    </when>
                    <otherwise>
                        <to
                            uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-pds-thumbs?amazonSQSClient=#sqsClient"
                        />
                    </otherwise>
                </choice>
                <doCatch>
                    <exception>java.lang.Exception</exception>
                    <to uri="direct:dead-letter"/>
                    <!--<to uri="file://{{librarycloud.files.basepath}}/dead-letter" />-->
                </doCatch>
            </doTry>
        </route>

        <route id="addthumbstomods-seda" errorHandlerRef="eh">
            <!-- <from uri="file://{{librarycloud.files.basepath}}//enrich-collections" /> -->
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-pds-thumbs?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"/>
            <unmarshal>
                <custom ref="cloudbody"/>
            </unmarshal>
            <to uri="seda:enrich-pds-thumbs?size=20&amp;blockWhenFull=true"/>
        </route>
        <route id="addthumbstomods" errorHandlerRef="eh">
            <from uri="seda:enrich-pds-thumbs?concurrentConsumers=5"/>
            <process ref="thumbsProcessor"/>
            <marshal>
                <custom ref="cloudbody"/>
            </marshal>
            <to
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-collections?amazonSQSClient=#sqsClient"/>
            <!-- <to uri="file://{{librarycloud.files.basepath}}/enrich-end" /> -->
        </route>

        <!-- collections here refers to "sets" in librarycloud -->
        <route id="addcollectionstomods-seda" errorHandlerRef="eh">
            <!-- <from uri="file://{{librarycloud.files.basepath}}//enrich-collections" /> -->
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-collections?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"/>
            <unmarshal>
                <custom ref="cloudbody"/>
            </unmarshal>
            <to uri="seda:enrich-collections?size=20&amp;blockWhenFull=true"/>
        </route>
        <route id="addcollectionstomods" errorHandlerRef="eh">
            <from uri="seda:enrich-collections?concurrentConsumers=5"/>
            <process ref="collectionsProcessor"/>
            <marshal>
                <custom ref="cloudbody"/>
            </marshal>
            <to
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-publish?amazonSQSClient=#sqsClient"
            />
        </route>


        <!-- Publishing records to consumers -->
        <route id="publish-seda" errorHandlerRef="eh">
            <!-- <from uri="file://{{librarycloud.files.basepath}}/enrich-end" /> -->
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-publish?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"/>
            <unmarshal>
                <custom ref="cloudbody"/>
            </unmarshal>
            <to uri="seda:enrich-publish?size=20&amp;blockWhenFull=true"/>
        </route>
        <route id="publish" errorHandlerRef="eh">
            <from uri="seda:enrich-publish?concurrentConsumers=1"/>
            <process ref="publishProcessor"/>

            <!-- not publishing for sns currently -->
            <!--<multicast>
                <to uri="direct:publish-delta"/>
                <to uri="direct:publish-full"/>
            </multicast>-->
            <to uri="direct:publish-delta"/>
        </route>

        <!-- Publish records that have changed -->
        <route id="publish-delta" errorHandlerRef="eh">
            <from uri="direct:publish-delta"/>
            <!-- Remove any items that haven't changed -->
            <!--<process ref="filterUnchangedProcessor"/>-->

            <!-- Don't try to publish empty messages -->
            <choice>
                <when>
                    <xpath>string-length(/lib_comm_message/payload/data) = 0</xpath>
                    <to
                        uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-empty-message?amazonSQSClient=#sqsClient"
                    />
                </when>
                <otherwise>
                    <marshal>
                        <custom ref="cloudbody"/>
                    </marshal>
                    <!-- <multicast> -->
                    <!-- Publishing to Solr doesn't yet go through the SNS publishing, so put it on its own queue -->
                    <to
                        uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-mods-to-solr?amazonSQSClient=#sqsClient"/>
                    <!--<to uri="aws-sns://harvard-librarycloud-publish-delta-{{librarycloud.sqs.environment}}?amazonSNSClient=#snsClient" /> -->
                    <!-- </multicast> -->
                </otherwise>
            </choice>
        </route>

        <!-- Publish all records -->
        <route id="publish-full" errorHandlerRef="eh">
            <from uri="direct:publish-full"/>

            <!-- Don't try to publish empty messages -->
            <choice>
                <when>
                    <xpath>string-length(/lib_comm_message/payload/data) = 0</xpath>
                    <to
                        uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-empty-message?amazonSQSClient=#sqsClient"
                    />
                </when>
                <otherwise>
                    <marshal>
                        <custom ref="cloudbody"/>
                    </marshal>
                    <!-- <to uri="aws-sns://harvard-librarycloud-publish-full-{{librarycloud.sqs.environment}}?amazonSNSClient=#snsClient" /> -->
                </otherwise>
            </choice>
        </route>

        <!-- SOLR consumer for loading into item API -->
        <route id="modstosolr-seda" errorHandlerRef="eh">
            <!--<from uri="file://{{librarycloud.files.basepath}}/publish-public-delta-solr" /> -->
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-mods-to-solr?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"/>
            <unmarshal>
                <custom ref="cloudbody"/>
            </unmarshal>
            <to uri="seda:mods-to-solr?size=20&amp;blockWhenFull=true"/>
        </route>
        <route id="modstosolr" errorHandlerRef="eh">
            <from uri="seda:mods-to-solr?concurrentConsumers=1"/>
            <process ref="solrLoadProcessor"/>
            <to
                uri="log:edu.harvard.libcomm.throughput?level=TRACE&amp;marker=solrLoadProcessor&amp;groupSize=10"/>
            <marshal>
                <custom ref="cloudbody"/>
            </marshal>
            <to
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-done?amazonSQSClient=#sqsClient"/>
            <!-- <to uri="file://{{librarycloud.files.basepath}}/done" /> -->
        </route>

        <!-- SOLR consumer for loading into item API where the updates should be commited immediately -->
        <route id="modstosolr-immediate" errorHandlerRef="eh">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-publish-public-immediate?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"/>
            <process ref="solrLoadProcessorImmediate"/>
            <to
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-done?amazonSQSClient=#sqsClient"
            />
        </route>

        <!-- DRS Extension Update handling - handles text file of urns, csv separated, line by line -->
        <route id="extension-update-ingest-split">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-ingest-extensions?amazonSQSClient=#sqsClient&amp;visibilityTimeout=1800"/>
            <!-- Try block required for errors thrown out of the splitter -->
            <doTry>
                <split streaming="true" parallelProcessing="true">
                    <method bean="updateSplitter" method="split"/>
                    <marshal>
                        <custom ref="cloudbody"/>
                    </marshal>
                    <to
                        uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-update-extensions?amazonSQSClient=#sqsClient"/>
                    <!--<to uri="seda:update-extensions?size=20&amp;blockWhenFull=true" />-->
                </split>
                <doCatch>
                    <exception>java.lang.Exception</exception>
                    <to uri="direct:dead-letter"/>
                </doCatch>
            </doTry>
        </route>

        <route id="updateextensions-seda" errorHandlerRef="eh">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-update-extensions?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"/>
            <unmarshal>
                <custom ref="cloudbody"/>
            </unmarshal>
            <to uri="seda:update-extensions?size=20&amp;blockWhenFull=true"/>
        </route>

        <route id="updateextensions" errorHandlerRef="eh">
            <!--<from uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-update-extensions?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10" />-->
            <from uri="seda:update-extensions?concurrentConsumers=500"/>
            <process ref="drsExtensionsNewUpdateProcessor"/>
            <to
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-drsextensionstosolr?amazonSQSClient=#sqsClient"
            />
        </route>

        <route id="drsextensionstosolr-seda" errorHandlerRef="eh">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-drsextensionstosolr?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"/>
            <unmarshal>
                <custom ref="cloudbody"/>
            </unmarshal>
            <to uri="seda:drsextensionstosolr?size=20&amp;blockWhenFull=true"/>
        </route>

        <route id="drsextensionstotosolr" errorHandlerRef="eh">
            <from uri="seda:drsextensionstosolr?concurrentConsumers=4"/>
            <!--<from uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-split-holdings?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10" />-->
            <!--<from uri="file://{{librarycloud.files.basepath}}/split-holdings"/>-->
            <process ref="solrDrsExtensionsProcessor"/>
            <marshal>
                <custom ref="cloudbody"/>
            </marshal>
            <to
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-done?amazonSQSClient=#sqsClient"/>
            <!--<to uri="file://{{librarycloud.files.basepath}}/done"/>-->
        </route>

        <!-- Delete handling -->

        <route id="alma-delete-extract-file">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-delete-alma?amazonSQSClient=#sqsClient&amp;visibilityTimeout=1800"/>
            <split>
                <xtokenize mode="t">//filepath</xtokenize>
                <bean ref="prepareURI" method="prepare"/>
                <!-- Download the file identified in the message header. This URI (http://www.example.com) is ignored -->
                <to uri="http://www.example.com"/>
                <to uri="direct:alma-delete-file"/>
            </split>
        </route>

        <route id="alma-delete-ingest-split">
            <from uri="direct:alma-delete-file"/>
            <!-- Try block required for errors thrown out of the splitter -->
            <doTry>
                <split streaming="true">
                    <xtokenize>//record</xtokenize>
                    <setHeader headerName="deleteID">
                        <xpath resultType="java.lang.String">//controlfield[@tag='001']</xpath>
                    </setHeader>
                    <setHeader headerName="source">
                        <simple>ALMA</simple>
                    </setHeader>
                    <process ref="deleteProcessor"/>
                    <multicast streaming="true">
                        <to
                            uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-delete-public?amazonSQSClient=#sqsClient"/>
                        <to
                            uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-delete-s3?amazonSQSClient=#sqsClient"
                        />
                    </multicast>
                </split>
                <doCatch>
                    <exception>java.lang.Exception</exception>
                    <to uri="direct:dead-letter"/>
                </doCatch>
            </doTry>
        </route>

        <route id="alma-suppressed-delete-extract-file">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-delete-alma-suppressed?amazonSQSClient=#sqsClient&amp;visibilityTimeout=1800"/>
            <split>
                <xtokenize mode="t">//filepath</xtokenize>
                <bean ref="prepareURI" method="prepare"/>
                <!-- Download the file identified in the message header. This URI (http://www.example.com) is ignored -->
                <to uri="http://www.example.com"/>
                <to uri="direct:alma-suppressed-delete-file"/>
            </split>
        </route>

        <route id="alma-suppressed-delete-ingest-split">
            <from uri="direct:alma-suppressed-delete-file"/>
            <!-- Try block required for errors thrown out of the splitter -->
            <doTry>
                <split streaming="true">
                    <!--<xtokenize>//record</xtokenize>-->
                    <xpath>//record[datafield[@tag='950']/subfield[@code='e']='true']</xpath>
                    <setHeader headerName="deleteID">
                        <xpath resultType="java.lang.String">//controlfield[@tag='001']</xpath>
                    </setHeader>
                    <setHeader headerName="source">
                        <simple>ALMA</simple>
                    </setHeader>
                    <process ref="deleteProcessor"/>
                    <multicast streaming="true">
                        <to
                            uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-delete-public?amazonSQSClient=#sqsClient"/>
                        <to
                            uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-delete-s3?amazonSQSClient=#sqsClient"
                        />
                    </multicast>
                </split>
                <doCatch>
                    <exception>java.lang.Exception</exception>
                    <to uri="direct:dead-letter"/>
                </doCatch>
            </doTry>
        </route>

        <!-- via deletes -->
        <route id="via-delete-extract-file">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-delete-via?amazonSQSClient=#sqsClient&amp;visibilityTimeout=1800"/>
            <split>
                <xtokenize mode="t">//filepath</xtokenize>
                <bean ref="prepareURI" method="prepare"/>
                <!-- Download the file identified in the message header. This URI (http://www.example.com) is ignored -->
                <to uri="http://www.example.com"/>
                <to uri="direct:via-delete-file"/>
            </split>
        </route>

        <route id="via-delete-ingest-split">
            <from uri="direct:via-delete-file"/>
            <!-- Try block required for errors thrown out of the splitter -->
            <doTry>
                <split streaming="true">
                    <xtokenize>//viaRecord</xtokenize>
                    <setHeader headerName="deleteID">
                        <xpath resultType="java.lang.String">//recordId</xpath>
                    </setHeader>
                    <setHeader headerName="source">
                        <simple>VIA</simple>
                    </setHeader>
                    <process ref="deleteProcessor"/>
                    <multicast streaming="true">
                        <to
                            uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-delete-public?amazonSQSClient=#sqsClient"
                        />
                    </multicast>
                </split>
                <doCatch>
                    <exception>java.lang.Exception</exception>
                    <to uri="direct:dead-letter"/>
                </doCatch>
            </doTry>
        </route>

        <!-- oasis deletes -->
        <route id="oasis-delete-extract-file">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-delete-oasis?amazonSQSClient=#sqsClient&amp;visibilityTimeout=1800"/>
            <split>
                <xtokenize mode="t">//filepath</xtokenize>
                <bean ref="prepareURI" method="prepare"/>
                <!-- Download the file identified in the message header. This URI (http://www.example.com) is ignored -->
                <to uri="http://www.example.com"/>
                <to uri="direct:oasis-delete-file"/>
            </split>
        </route>

        <route id="oasis-delete-ingest-split" xmlns:ead="urn:isbn:1-931666-22-9">
            <from uri="direct:oasis-delete-file"/>
            <!-- Try block required for errors thrown out of the splitter -->
            <doTry>
                <setHeader headerName="deleteID">
                    <xpath resultType="java.lang.String">//ead:eadid/text()</xpath>
                </setHeader>
                <setHeader headerName="source">
                    <simple>OASIS</simple>
                </setHeader>
                <process ref="deleteProcessor"/>
                <to
                    uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-delete-public?amazonSQSClient=#sqsClient"/>
                <doCatch>
                    <exception>java.lang.Exception</exception>
                    <to uri="direct:dead-letter"/>
                </doCatch>
            </doTry>
        </route>

        <route id="deletesolr" errorHandlerRef="eh">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-delete-public?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"/>
            <process ref="solrDeleteProcessor"/>
            <to
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-done?amazonSQSClient=#sqsClient"
            />
        </route>

        <!-- Delete holdings handling -->
        <route id="alma-holdings-delete-extract-file">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-delete-alma-holdings?amazonSQSClient=#sqsClient&amp;visibilityTimeout=1800"/>
            <split>
                <xtokenize mode="t">//filepath</xtokenize>
                <bean ref="prepareURI" method="prepare"/>
                <!-- Download the file identified in the message header. This URI (http://www.example.com) is ignored -->
                <to uri="http://www.example.com"/>
                <to uri="direct:alma-holdings-delete-file"/>
            </split>
        </route>

        <route id="alma-holdings-delete-ingest-split">
            <from uri="direct:alma-holdings-delete-file"/>
            <!-- Try block required for errors thrown out of the splitter -->
            <doTry>
                <split streaming="true">
                    <xtokenize>//record</xtokenize>
                    <setHeader headerName="deleteID">
                        <xpath resultType="java.lang.String">//datafield[@tag='852']/subfield[@code='8']</xpath>
                    </setHeader>
                    <setHeader headerName="source">
                        <simple>ALMA</simple>
                    </setHeader>
                    <process ref="deleteProcessor"/>
                    <to
                        uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-delete-holdings-public?amazonSQSClient=#sqsClient"
                    />
                </split>
                <doCatch>
                    <exception>java.lang.Exception</exception>
                    <to uri="direct:dead-letter"/>
                </doCatch>
            </doTry>
        </route>

        <route id="deleteholdingssolr" errorHandlerRef="eh">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-delete-holdings-public?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"/>
            <process ref="solrHoldingsDeleteProcessor"/>
            <to
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-done?amazonSQSClient=#sqsClient"
            />
        </route>

        <!-- Collection update handling -->
        <route id="updatecollections-seda" errorHandlerRef="eh">
            <!--<from uri="file://{{librarycloud.files.basepath}}/updateCollection-input" /> -->
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-update-public?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"/>
            <to uri="seda:update-public?size=20&amp;blockWhenFull=true"/>
        </route>

        <route id="updateCollection" errorHandlerRef="eh">
            <from uri="seda:update-public?concurrentConsumers=1"/>
            <process ref="collectionUpdateProcessor"/>
            <choice>
                <when>
                    <xpath>string-length(/lib_comm_message/payload/data) = 0</xpath>
                    <to
                        uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-empty-message?amazonSQSClient=#sqsClient"
                    />
                </when>
                <otherwise>
                    <to
                        uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-publish-public-immediate?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"
                    />
                </otherwise>
            </choice>
        </route>

        <!-- TED -->

        <route id="ted-ingest-split" errorHandlerRef="eh">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-ingest-ted?amazonSQSClient=#sqsClient&amp;visibilityTimeout=1800"/>
            <doTry>
                <split streaming="true" parallelProcessing="true">
                    <method bean="tedSplitter" method="split"/>
                    <marshal>
                        <custom ref="cloudbody"/>
                    </marshal>
                    <to
                        uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-drs-extensions?amazonSQSClient=#sqsClient"/>
                    <!--<to uri="file://{{librarycloud.files.basepath}}/TEDSPLIT?fileName=${header.CamelSplitIndex}" />-->
                </split>
                <doCatch>
                    <exception>java.lang.Exception</exception>
                    <to uri="direct:dead-letter"/>
                    <!--<to uri="file://{{librarycloud.files.basepath}}/dead-letter" />-->
                </doCatch>
            </doTry>
        </route>

        <route id="bibidlist-from-holdings-ingest" errorHandlerRef="eh">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-update-bibidsfromholdings?amazonSQSClient=#sqsClient&amp;visibilityTimeout=1800&amp;extendMessageVisibility=true"/>
            <split>
                <xtokenize mode="t">//filepath</xtokenize>
                <bean ref="prepareURI" method="prepare"/>
                <!-- Download the file identified in the message header. This URI (http://www.example.com) is ignored -->
                <to uri="http://www.example.com"/>
                <to uri="direct:bibidlist-from-holdings-file"/>
            </split>
        </route>

        <route id="bibidlist-from-holdings-file">
            <from uri="direct:bibidlist-from-holdings-file"/>
            <!--<from uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-update-bibidsfromholdings?amazonSQSClient=#sqsClient&amp;visibilityTimeout=1800" />-->
            <!--<from uri="file://{{librarycloud.files.basepath}}/HOLTEST"/>-->
            <!-- Try block required for errors thrown out of the splitter -->
            <doTry>
                <split>
                    <xpath>//controlfield[@tag='001']/text()</xpath>

                    <setHeader headerName="outerSplitIndex">
                        <simple>${header.CamelSplitIndex}</simple>
                    </setHeader>
                    <aggregate strategyRef="newlineAggregator" completionSize="100"
                        completionInterval="10000">
                        <correlationExpression>
                            <simple>all</simple>
                        </correlationExpression>
                        <!--<completionPredicate>
                            <simple>${header.messageLength} > 150000</simple>
                        </completionPredicate>-->
                        <to
                            uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-update-bibids?amazonSQSClient=#sqsClient"
                        />
                    </aggregate>
                    <!--<to uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-update-bibids?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10" />-->
                </split>
            </doTry>
        </route>

        <!-- update alma from s3 -->
        <route id="alma-refreshfroms3-split">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-update-bibids?amazonSQSClient=#sqsClient&amp;visibilityTimeout=1800"/>
            <!--<from uri="file://{{librarycloud.files.basepath}}/refreshfroms3-alma"/>-->
            <!-- Try block required for errors thrown out of the splitter -->
            <doTry>
                <split streaming="true">
                    <tokenize token="\r\n|\n" xml="false" trim="true"/>
                    <process ref="refreshFromS3Processor"/>
                    <!--<to uri="file://{{librarycloud.files.basepath}}/normalize-marcxml"/>-->
                    <to
                        uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-normalize-marcxml?amazonSQSClient=#sqsClient"
                    />
                </split>
            </doTry>
        </route>

        <route id="deletefroms3" errorHandlerRef="eh">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-delete-s3?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"/>
            <process ref="s3DeleteProcessor"/>
            <to
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-done?amazonSQSClient=#sqsClient"
            />
        </route>


        <!-- 20190926 - adding activemq and drsmds routes for ingesting drs metadata from new mongo api into "extensions" solr, -->
        <!-- and triggering realtime update into matching bibrecs -->

        <route id="activemqDrs" errorHandlerRef="eh">
            <from
                uri="activemq:Consumer.librarycloud-{{librarycloud.sqs.environment}}.VirtualTopic.DRS_OBJECT_UPDATED"/>
            <!--<from uri="activemq:Consumer.Consumer1.VirtualTopic.DRS_OBJECT_UPDATED"/>-->
            <setHeader headerName="drsId">
                <jsonpath>$.data.objectId</jsonpath>
            </setHeader>
            <transform>
                <simple>${header.drsId}</simple>
            </transform>
            <process ref="drsMdsProcessor"/>
            <!--<to uri="file://{{librarycloud.files.basepath}}/DRSMDS"/>-->
            <!--<to uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-drs-mds?amazonSQSClient=#sqsClient"/>-->
            <choice>
                <when>
                    <simple>${in.body} != "[]"</simple>
                    <to uri="seda:drs-mds?size=20&amp;blockWhenFull=true"/>
                </when>
                <otherwise>
                    <to
                        uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-empty-message?amazonSQSClient=#sqsClient"
                    />
                </otherwise>
            </choice>
        </route>

        <!-- this is for refreshing drs ids by loading files to queue, if for istance there is a failure above -->
        <route id="updatedrsids">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-update-drsids?amazonSQSClient=#sqsClient&amp;visibilityTimeout=1800"/>
            <!--<from uri="file://{{librarycloud.files.basepath}}/refreshfroms3-alma"/>-->
            <!-- Try block required for errors thrown out of the splitter -->
            <doTry>
                <split streaming="true">
                    <tokenize token="\r\n|\n" xml="false" trim="true"/>
                    <process ref="drsMdsProcessor"/>
                    <!--<to uri="file://{{librarycloud.files.basepath}}/normalize-marcxml"/>-->
                    <choice>
                        <when>
                            <simple>${in.body} != "[]"</simple>
                            <to uri="seda:drs-mds?size=20&amp;blockWhenFull=true"/>
                        </when>
                        <otherwise>
                            <to
                                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-empty-message?amazonSQSClient=#sqsClient"
                            />
                        </otherwise>
                    </choice>
                </split>
            </doTry>
        </route>

        <route id="drsMdsToSolr" errorHandlerRef="eh">
            <!--<from uri="file://{{librarycloud.files.basepath}}/DRSMDS"/>-->
            <!--<from uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-drs-mds?amazonSQSClient=#sqsClient"/>-->
            <from uri="seda:drs-mds?concurrentConsumers=1"/>
            <process ref="drsMdsSolrProcessor"/>
            <to
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-drs-mds-update?amazonSQSClient=#sqsClient"
            />
        </route>
        <route id="drsMdsUpdate" errorHandlerRef="eh">
            <!--<from uri="file://{{librarycloud.files.basepath}}/DRSMDS"/>-->
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-drs-mds-update?amazonSQSClient=#sqsClient"/>

            <split streaming="true">
                <jsonpath>$</jsonpath>
                <aggregate completionSize="100" completionTimeout="1000" groupExchanges="true">
                    <correlationExpression>
                        <constant>true</constant>
                    </correlationExpression>
                    <process ref="drsMdsUpdateProcessor"/>
                    <marshal>
                        <custom ref="cloudbody"/>
                    </marshal>
                    <to
                        uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-drs-metadata?amazonSQSClient=#sqsClient"
                    />
                </aggregate>
            </split>
        </route>

        <route id="adddrsmetadataimmediate-seda" errorHandlerRef="eh">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-drs-metadata?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"/>
            <unmarshal>
                <custom ref="cloudbody"/>
            </unmarshal>
            <to uri="seda:enrich-drs-metadata?size=20&amp;blockWhenFull=true"/>
        </route>
        <route id="adddrsextensionstomodsImmediate" errorHandlerRef="eh">
            <!--<from uri="file://{{librarycloud.files.basepath}}//enrich-drs-extensions" />-->
            <from uri="seda:enrich-drs-metadata?concurrentConsumers=1"/>

            <choice>
                <when>
                    <xpath>string-length(/lib_comm_message/payload/data) = 0</xpath>
                    <to
                        uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-empty-message?amazonSQSClient=#sqsClient"
                    />
                </when>
                <otherwise>
                    <doTry>
                        <process ref="drsExtensionsProcessor"/>
                        <marshal>
                            <custom ref="cloudbody"/>
                        </marshal>
                        <to
                            uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-publish-immediate?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"/>
                        <!-- <to uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-publish-public-immediate?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10" />-->
                        <doCatch>
                            <exception>java.lang.Exception</exception>
                            <to uri="direct:dead-letter"/>
                            <!--<to uri="file://{{librarycloud.files.basepath}}/dead-letter" />-->
                        </doCatch>
                    </doTry>
                </otherwise>
            </choice>

        </route>

        <route id="publish-immmediate-seda" errorHandlerRef="eh">
            <from
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-enrich-publish-immediate?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"/>
            <unmarshal>
                <custom ref="cloudbody"/>
            </unmarshal>
            <to uri="seda:enrich-publish-immediate?size=20&amp;blockWhenFull=true"/>
        </route>
        <route id="publish-immediate" errorHandlerRef="eh">
            <from uri="seda:enrich-publish-immediate?concurrentConsumers=1"/>
            <process ref="publishProcessor"/>
            <to
                uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-publish-public-immediate?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10"
            />
        </route>


        <!--
        <route id="fullRefresh" errorHandlerRef="eh">
            <from uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-update-allbibs?amazonSQSClient=#sqsClient&amp;maxMessagesPerPoll=10" />
            <process ref="s3FullListProcessor"/>
            <to uri="aws-sqs://librarycloud-{{librarycloud.sqs.environment}}-done?amazonSQSClient=#sqsClient"/>
        </route>
-->
    </camelContext>
</beans>
